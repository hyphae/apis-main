---
status: proposed
# date: 2025-11-15
# decision-makers: {Hyphae APIS development team}
---
# Use Embedded Token Service for OpenPAYGO Integration with Hyphae APIS

## Context and Problem Statement

Hyphae APIS (Autonomous Power Interchange System) requires integration with OpenPAYGO token validation to enable pay-as-you-go autonomous power exchange within distributed microgrids. The system needs to validate cryptographic tokens before authorizing energy sharing requests, track energy consumption in real-time, and deduct consumed kWh from user token balances.

The core question is: Should OpenPAYGO token validation be embedded as a Vert.x verticle within the existing apis-main Java application, or should it be deployed as a separate microservice?

## Decision Drivers

* Minimizing operational complexity and deployment overhead
* Reducing network latency for critical token validation operations
* Maintaining single deployment artifact for simplified operations
* Leveraging existing Hazelcast infrastructure for state management
* Ensuring reliability in offline/low-connectivity environments
* Reducing infrastructure costs (single service vs multiple services)
* Simplifying monitoring and troubleshooting (single application)
* Maintaining technology stack consistency (Java ecosystem)

## Considered Options

* Embedded Token Service (OpenPAYGO validation as Vert.x verticle within apis-main)
* Microservice Architecture (Token Service as separate Python/FastAPI service)

## Decision Outcome

Chosen option: "Embedded Token Service", because it eliminates network dependencies for token validation, simplifies deployment to single-board computers (Raspberry Pi) in remote off-grid locations, reduces operational overhead by maintaining a single application artifact, and leverages existing APIS infrastructure (Hazelcast, Vert.x event bus) for optimal performance and reliability in environments with intermittent connectivity.

### Consequences

* Good, because eliminates network latency for token validation (in-process communication, sub-millisecond)
* Good, because maintains single deployment artifact, reducing operational complexity
* Good, because leverages existing Hazelcast distributed memory for efficient token state management
* Good, because simplifies deployment to resource-constrained edge devices (Raspberry Pi, BeagleBone)
* Good, because reduces infrastructure costs by eliminating need for separate service containers and orchestration
* Good, because improves reliability in offline scenarios - no network dependency for validation
* Good, because simplifies monitoring and logging with single application to observe
* Good, because maintains technology stack consistency within Java ecosystem
* Good, because reduces attack surface with fewer network endpoints to secure
* Bad, because requires Java reimplementation of OpenPAYGO token algorithm (divergence from reference implementation)
* Bad, because tightly couples token service lifecycle with APIS - updates require full application restart
* Bad, because token service bugs or performance issues can impact entire APIS application
* Bad, because cannot independently scale token validation separate from energy trading operations
* Bad, because increases apis-main complexity and jar size with additional dependencies
* Bad, because requires maintaining compatibility between Java reimplementation and official OpenPAYGO spec

### Confirmation

The implementation can be confirmed through:
* Unit tests verifying Java OpenPAYGO implementation matches reference test vectors from official Python library
* Interoperability testing confirming tokens generated by OpenPAYGO-python validate correctly in Java implementation
* Cryptographic audit of SipHash-2-4 implementation against official specification
* Performance testing showing token validation completes in sub-millisecond timeframes
* Integration testing demonstrating seamless token validation within APIS User Service
* Offline testing confirming token validation works without network connectivity
* Load testing validating embedded service handles expected validation volumes without impacting energy trading
* Memory profiling ensuring embedded service doesn't cause excessive heap usage or GC pressure

## Pros and Cons of the Options

### Embedded Token Service

Deploy OpenPAYGO validation as a Vert.x verticle embedded within the apis-main Java application using Java reimplementation of OpenPAYGO token algorithm.

* Good, because eliminates network latency - token validation occurs in-process (sub-millisecond)
* Good, because maintains single deployment artifact, simplifying CI/CD pipeline and operations
* Good, because leverages Hazelcast distributed memory already used by APIS for token state
* Good, because shares Vert.x event bus for non-blocking async communication between services
* Good, because simplifies deployment to edge devices (single jar vs container orchestration)
* Good, because reduces infrastructure costs - no additional containers, load balancers, or service mesh
* Good, because improves offline reliability - no network dependency for token validation
* Good, because simplifies monitoring with single application (one JVM to monitor)
* Good, because maintains technology stack consistency within Java ecosystem
* Good, because reduces attack surface with fewer exposed network endpoints
* Good, because enables transaction-level integration with APIS deal execution
* Bad, because requires Java reimplementation of OpenPAYGO (SipHash-2-4, token generation/validation logic)
* Bad, because divergence risk from official OpenPAYGO specification as it evolves
* Bad, because tightly couples token service with APIS - all updates require full application restart
* Bad, because token service memory leaks or bugs can crash entire APIS application
* Bad, because cannot scale token validation independently from energy trading operations
* Bad, because increases apis-main jar size and application complexity
* Bad, because testing requires spinning up full APIS application, slowing test iterations
* Bad, because constrained to JVM languages for token service implementation

### Microservice Architecture

Deploy Token Service as a separate Python/FastAPI application communicating with apis-main via REST/HTTP.

* Good, because enables direct use of official OpenPAYGO-python library without reimplementation
* Good, because provides strong fault isolation - token failures don't affect energy trading
* Good, because allows independent deployment and version management
* Good, because enables independent horizontal scaling based on token validation load
* Good, because FastAPI provides excellent async/await performance for I/O-bound operations
* Good, because simplifies team organization - separate ownership boundaries
* Good, because service can be reused across multiple APIS clusters
* Good, because easier testing with language-native tools and mock services
* Good, because enables gradual migration strategy alongside existing system
* Bad, because introduces 10-50ms network latency per token validation request
* Bad, because requires additional infrastructure (containers, orchestration, service discovery)
* Bad, because increases operational complexity with separate monitoring, logging, alerting
* Bad, because requires implementing retry logic and circuit breakers for network resilience
* Bad, because adds inter-service security requirements (mTLS, API authentication)
* Bad, because network partitions can cause validation failures
* Bad, because complicates deployment to resource-constrained edge devices
* Bad, because increases infrastructure costs (additional compute, storage, networking)

## More Information

### Java OpenPAYGO Implementation Strategy

To minimize divergence risk from the official OpenPAYGO specification, the Java implementation will:

1. **Direct port of reference implementation**: Translate OpenPAYGO-python logic line-by-line to Java
2. **Comprehensive test suite**: Use official test vectors from OpenPAYGO specification
3. **Automated compatibility testing**: CI pipeline validates against OpenPAYGO-python outputs
4. **Regular synchronization**: Monitor OpenPAYGO spec changes and update Java implementation
5. **Open source contribution**: Publish Java implementation for community review and adoption

**Example Java implementation structure:**

```java
package jp.co.sony.csl.dcoes.apis.main.app.token;

public class OpenPAYGOTokenGenerator {
    private final SipHash24 hasher;
    
    public TokenResult generateToken(
        String secretKey, 
        int currentCount, 
        int value, 
        TokenType type
    ) {
        // Direct port of OpenPAYGO-python generate_token()
        // Implementation validated against official test vectors
    }
    
    public ValidationResult decodeToken(
        String token,
        String secretKey,
        int currentCount,
        List<Integer> usedCounts
    ) {
        // Direct port of OpenPAYGO-python decode_token()
        // Implementation validated against official test vectors
    }
}
```

### SipHash-2-4 Library Selection

Java implementation will use **Guava's SipHash implementation** (`com.google.common.hash.Hashing.sipHash24()`):
* Already included in APIS dependencies (no additional jar size)
* Well-tested by Google with extensive production usage
* Matches OpenPAYGO's SipHash-2-4 specification
* Performance benchmarks show <1Î¼s per hash operation

Alternative: Apache Commons Crypto (if Guava proves insufficient)

### Deployment Simplification

**Single jar deployment benefits for edge devices:**

```bash
# Embedded approach - single command
scp apis-main-with-token.jar pi@node1:/opt/apis/
ssh pi@node1 "systemctl restart apis"

# vs Microservice approach - multiple steps
docker-compose up -d token-service
kubectl apply -f token-service-deployment.yaml
scp apis-main.jar pi@node1:/opt/apis/
# Update configuration to point to token service
ssh pi@node1 "systemctl restart apis"
```

### Performance Characteristics

Based on APIS production deployment (19 residences, 170 kWh monthly trading):

**Token validation performance targets:**
* Embedded: <1ms per validation (in-process method call)
* Microservice: 10-50ms per validation (network round-trip)

**For typical energy sharing scenario:**
* 1 validation per energy request (every 2-3 hours)
* 10-12 consumption reports per charge cycle (5 kWh over 1 hour)
* Network latency impact: **Negligible** for energy trading timescales

**Verdict:** For APIS's low-frequency validation needs (10-20 per hour per node), even microservice latency is acceptable. Embedded approach provides no practical performance benefit but trades operational simplicity.

### Risk Assessment

**Embedded approach risks:**
* **Medium risk**: Java implementation divergence from OpenPAYGO spec
  * *Mitigation*: Automated test suite against official test vectors, regular synchronization
* **Low risk**: Token service bugs affecting APIS stability
  * *Mitigation*: Comprehensive unit tests, fault-tolerant error handling
* **Low risk**: Inability to independently scale token validation
  * *Mitigation*: APIS validation frequency is inherently low, scaling not required

**Microservice approach risks:**
* **Medium risk**: Network latency impacting user experience
  * *Mitigation*: Aggressive caching, async validation patterns
* **High risk**: Operational complexity in remote deployments
  * *Mitigation*: Invest in DevOps tooling, but fundamental complexity remains
* **Low risk**: Inter-service communication failures
  * *Mitigation*: Circuit breakers, retry logic, graceful degradation

### Target Deployment Environment

APIS is designed for off-grid microgrids in remote locations with:
* **Hardware**: Raspberry Pi 3/4, BeagleBone Black (limited resources)
* **Network**: Intermittent connectivity, high latency, low bandwidth
* **Operations**: Limited technical staff, minimal infrastructure

**Embedded approach advantages in this environment:**
* Single service to deploy, monitor, and troubleshoot
* No dependency on network for token validation
* Lower resource footprint (single JVM vs multiple containers)
* Simpler backup/restore (one application state)

### Migration Path

If embedded approach faces scaling limitations or divergence issues:

**Phase 1** (Week 1-2): Extract Java token implementation to separate package
**Phase 2** (Week 3): Create REST wrapper around token package  
**Phase 3** (Week 4): Deploy wrapped service alongside APIS
**Phase 4** (Week 5-6): Update TokenServiceClient to use HTTP instead of in-process calls
**Phase 5** (Week 7): Gradual rollout with feature flag switch

Starting embedded provides fastest time-to-market while preserving migration option.

### Related Implementations

Several energy systems successfully embed payment/metering logic:
* **Smart meters**: Itron, Landis+Gyr embed payment validation in meter firmware
* **Solar home systems**: Azuri PayGo, M-KOPA embed token validation in device controllers
* **EV charging stations**: ChargePoint, EVBox embed payment logic in charging hardware

These precedents demonstrate viability of embedded payment validation in energy applications.
